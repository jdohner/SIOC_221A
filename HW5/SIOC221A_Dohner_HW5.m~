% file SIOC 221A HW 5
% 
% author Julia Dohner
%
% due date November 2, 2017

clear all; close all;

%% Compute two spectra - attempt via Lecture 7 Notes

% compute two spectra for white noise and autorecessive datasets by
% breaking the data up into segments

N = 10000; % length of each chunk of data
M = 500;
p = N/M;

% generating 10,000 element dataset with Gaussian white noise
a=randn(N,1);
b(1) = a(1);
% generating a second dataset using autoregressive process
for i=2:length(a)
    b(i)=.5*b(i-1)+a(i);
end

a_reshape = reshape(a,N/M,M);
b_reshape = reshape(b,N/M,M);
f_a = fft(a_reshape);
f_b = fft(b_reshape);
for i = 1:floor(N/M);
    amp_a(:,i) = abs(f_a(1:(N/2+1))).^2; % for even N
    amp_b(:,i) = abs(f_b(1:(N/2+1))).^2; % for even N
end

frequency=(0:N/2)/N; % for N even
mean_amp_a = mean(amp_a,2);
mean_amp_b = mean(amp_b,2);
figure
semilogy(frequency,mean_amp_a, '-r', frequency, mean_amp_b, '-b')

%% Compute two spectra - my initial attempt

% generating 10,000 element dataset with Gaussian white noise
a=randn(10000,1);
b(1) = a(1);
% generating a second dataset using autoregressive process
for i=2:length(a)
    b(i)=.5*b(i-1)+a(i);
end

% compute two spectra for white noise and autorecessive datasets by
% breaking the data up into segments

% reshaping data vector into 500x20 matrix
a_reshape = reshape(a,[500,20]); % suggestion for getting red, white spectra
b_reshape = reshape(b,[500,20]);
%a_test = a_reshape(:,1);

% % Question: when you reshape, does it calculate individual fft of each
% column? - Yes
f_a = fft(a_reshape);
f_b = fft(b_reshape);
% f_test = fft(a_test);
% f_firstcola = f_a(:,1);

% more rigorous way of ensuring calculating ffts of individual columns
% for i = 1:20
%     fft_a(:,i) = fft(a_reshape(:,i));
%     fft_b(:,i) = fft(b_reshape(:,i));
% end

% plotting spectra of a and b
N = 500; % length of each chunk of data
% Question: is this fine for the chunks in columns? probably no because
% amp_a becomes a 1x251 double
% amp_a = abs(f_a(1:N/2+1)).^2; % for even N
% amp_b = abs(f_b(1:N/2+1)).^2; % for even N

% pre-allocating for speed
amp_a = zeros(251,20);
amp_b = zeros(251,20);
for i = 1:20
    % Question: the +1 seems problematic because then I end up with 251x20
    % vectors
    amp_a(:,i) = abs(f_a(1:N/2+1)).^2; % for even N
    amp_b(:,i) = abs(f_b(1:N/2+1)).^2; % for even N
end


% summing over all spectra (taken from lecture 7 notes- seems weird)

% turning into row vectors to plot
% amp_a = amp_a(:);
% amp_b = amp_b(:);

% meeting notes: take mean across rows
mean_amp_a = mean(amp_a,2)/(N/2); % 2 is taking mean across second dimension (each row)
% default is dim 1, which is each column
% 250 freqs, 20 datasets
% can think of 20 thermistors on pier, ft each time series, average
% together to get typical spectrum for whole record
mean_amp_b = mean(amp_b,2)/(N/2); % multiplying by 2 bc taking half frequencies, divide by N to normalize
% technically don't do to freq 0, but won't be looking at freq 0


% Question: how to create frequency vector?

% figure
% what is happening here is that each spectrum is individually calculated-
% they all look red. Then when they get plotted together like this they're
% just stuck next to each other, which makes it look like it's oscillating
%semilogy(1:5020,amp_a, '-m', 1:5020, amp_b,'-b')
figure
semilogy(0:250,mean_amp_a, 0:250, mean_amp_b, '-b');
title('\fontsize{14}Spectra for white noise, autoregressive data');
xlabel('\fontsize{12}frequency'); % freq is arbitrary, technically cycles per length of data
ylabel('\fontsize{12}(units)^2 / frequency'); % y is arbitrary energy, raw data squared, divide by freq

% seems liek there's a lot of noise, go on to next section, look at error
% bars, see if wiggles are consistent with error bars, if not, look at code
%could also make dataset larger (200 instead of 20)

% summing: want energy in each segment (lect 7 notes)
% mean: want typical energy
% need to divide by length of segment to get the energy to work out
% (normalize appropriately)
